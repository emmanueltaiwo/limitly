---
title: createClient()
description: Creates a new Limitly client instance for advanced configurations and custom rate limiting setups.
---

# createClient(config?)

Creates a new Limitly client instance with custom configuration. Use this when you need more control over the client behavior, such as custom service IDs, timeouts, or Redis connections.

## Function Signature

```typescript
function createClient(config?: LimitlyConfig): LimitlyClient
```

## Parameters

### `config` (optional)

Configuration object for the client:

```typescript
interface LimitlyConfig {
  baseUrl?: string;        // Base URL of the Limitly API service (default: https://api.limitly.emmanueltaiwo.dev)
  serviceId?: string;      // Service identifier for isolation
  timeout?: number;        // Request timeout in milliseconds (default: 5000)
  redisUrl?: string;       // Redis connection URL (optional, uses HTTP API if not provided)
}
```

**Note:** When `redisUrl` is provided, the SDK connects directly to your Redis. When not provided, it uses the HTTP API mode (hosted service).

## Returns

A `LimitlyClient` instance with the following methods:

- `checkRateLimit(options?)` - Check if a request is allowed
- Other client methods (see API reference)

## Basic Usage

Create a client with default settings:

```typescript
import { createClient } } from 'limitly-sdk';

const client = createClient();
```

## Custom Service ID

Isolate rate limits by service or application:

```typescript
const client = createClient({
  serviceId: 'my-api-service'
});

// All rate limits using this client will be isolated under 'my-api-service'
const result = await client.checkRateLimit({
  identifier: 'user-123'
});
```

This is useful when you have multiple services and want to keep their rate limits separate:

```typescript
// API service
const apiClient = createClient({ serviceId: 'api-service' });

// Authentication service
const authClient = createClient({ serviceId: 'auth-service' });

// Background job service
const jobClient = createClient({ serviceId: 'job-service' });

// Each service has independent rate limit buckets
await apiClient.checkRateLimit({ identifier: 'user-123' });
await authClient.checkRateLimit({ identifier: 'user-123' });
await jobClient.checkRateLimit({ identifier: 'user-123' });
```

## Bring Your Own Redis

Provide your own Redis URL for full tenant isolation:

```typescript
const client = createClient({
  redisUrl: 'redis://localhost:6379',
  serviceId: 'my-app'
});

// All rate limit data stored in your Redis
const result = await client.checkRateLimit('user-123');
```

When `redisUrl` is provided:
- SDK connects directly to your Redis
- Full tenant isolation (no collisions with other users)
- No HTTP requests to the hosted service
- All data stored in your Redis instance

When `redisUrl` is not provided:
- SDK uses HTTP API mode (hosted service)
- Works out of the box with zero configuration

## Custom Timeout

Set a custom timeout for HTTP requests:

```typescript
const client = createClient({
  serviceId: 'my-app',
  timeout: 3000  // 3 seconds timeout
});
```

This is useful when:
- You want faster failure detection
- Your network has higher latency
- You're using a remote API service

## Environment-Based Configuration

Create different clients for different environments:

```typescript
// config/limitly.ts
import { createClient } from 'limitly-sdk';

const isProduction = process.env.NODE_ENV === 'production';

// Use your own Redis in production
export const limitlyClient = createClient({
  serviceId: process.env.SERVICE_ID || 'default',
  redisUrl: process.env.REDIS_URL, // Optional: uses HTTP API if not provided
  timeout: parseInt(process.env.TIMEOUT || '5000', 10)
});

// Development: use local Redis
export const devClient = createClient({
  serviceId: 'dev',
  redisUrl: 'redis://localhost:6379',
  timeout: 5000
});

// Production: use your own Redis for isolation
export const prodClient = createClient({
  serviceId: process.env.SERVICE_ID || 'production',
  redisUrl: process.env.REDIS_URL!, // Your Redis instance
  timeout: 5000
});

// Or use HTTP API mode (no Redis needed)
export const apiClient = createClient({
  serviceId: 'my-app'
  // No redisUrl = uses HTTP API
});
```

## Multiple Clients

Create multiple clients for different use cases:

```typescript
// Strict rate limiting for authentication
const authClient = createClient({
  serviceId: 'auth',
  timeout: 2000
});

// Lenient rate limiting for public APIs
const publicClient = createClient({
  serviceId: 'public-api',
  timeout: 5000
});

// Background job rate limiting
const jobClient = createClient({
  serviceId: 'background-jobs',
  timeout: 10000
});
```

## Error Handling

Handle connection errors gracefully:

```typescript
import { createClient } from 'limitly-sdk';

const client = createClient({
  serviceId: 'my-app',
  redisUrl: process.env.REDIS_URL
});

async function checkLimitSafely(userId: string) {
  try {
    const result = await client.checkRateLimit({ identifier: userId });
    return result;
  } catch (error) {
    // Handle Redis connection errors
    if (error instanceof Error) {
      console.error('Rate limit check failed:', error.message);
    }
    
    // Fail open - allow request if rate limiting fails
    return {
      allowed: true,
      error: 'Rate limit service unavailable'
    };
  }
}
```

## Best Practices

1. **Use service IDs**: Always specify a `serviceId` to isolate rate limits
3. **Connection pooling**: Limitly handles connection pooling automatically
4. **Singleton pattern**: Create clients once and reuse them:

```typescript
// lib/limitly.ts
import { createClient } from 'limitly-sdk';

let client: ReturnType<typeof createClient> | null = null;

export function getLimitlyClient() {
  if (!client) {
    client = createClient({
      serviceId: process.env.SERVICE_ID || 'default',
      redisUrl: process.env.REDIS_URL // Optional: uses HTTP API if not provided
    });
  }
  return client;
}
```
